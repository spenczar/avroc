from typing import DefaultDict, List, Dict, Callable, Set

import collections
import platform
import sys

from avroc.codegen.graph import find_recursive_types
from avroc.util import SchemaType, rand_str
from avroc.schema import expand_names, gather_named_types


if sys.version_info >= (3, 9):
    from ast import unparse

    unparse_available = True
else:

    def unparse(x):
        return ""

    unparse_available = False


class Compiler:
    schema: SchemaType
    variable_name_counts: DefaultDict[str, int]

    # List of schemas which are defined recursively. This is needed to generate
    # separate functions for each of these types so that they can call
    # themselves recursively when reading.
    recursive_types: List[Dict]

    # Types by absolute name
    named_types: Dict[str, SchemaType]

    types_referenced_by_name: Set[str]

    pure_python: bool

    entrypoint_name: str

    debug: bool = True

    def __init__(self, schema: SchemaType, entrypoint_name: str):
        self.schema = expand_names(schema)
        self.named_types = gather_named_types(self.schema)
        self.types_referenced_by_name = set()

        self.entrypoint_name = entrypoint_name
        self.recursive_types = find_recursive_types(self.schema)

        self.variable_name_counts = collections.defaultdict(int)
        self.pure_python = platform.python_implementation() != "CPython"

    def new_variable(self, name: str) -> str:
        """
        Returns a new name for a variable which is guaranteed to be unique.
        """
        count = self.variable_name_counts[name]
        self.variable_name_counts[name] = count + 1
        if count == 0:
            return f"{name}"
        return f"{name}{count}"

    def compile(self, _populate_linecache=unparse_available) -> Callable:
        module = self.generate_module()

        if _populate_linecache:
            if not unparse_available:
                raise NotImplementedError(
                    "cannot provide source code in Python < 3.9 because AST cannot be unparsed"
                )
            import linecache

            source_code = unparse(module)
            if self.debug:
                print(source_code)
            filename = f"autogenerated_file_{rand_str(8)}.py"
            compiled = compile(source_code, filename, mode="exec")
            source_lines = source_code.splitlines()
            linecache.cache[filename] = (  # type: ignore
                len(source_lines),
                None,
                source_lines,
                filename,
            )
        else:
            filename = "<generated>"
            compiled = compile(module, filename, mode="exec")
        namespace = {}  # type: ignore
        exec(compiled, namespace)
        return namespace[self.entrypoint_name]  # type: ignore

    def generate_module(self):
        raise NotImplementedError("should be implemented by subclasses")
